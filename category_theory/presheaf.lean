import category_theory.adjunction
import category_theory.opposites
import category_theory.types
import category_theory.yoneda
import category_theory.limits
import category_theory.limits.functor_category
import category_theory.limits.types
import data.equiv.basic

namespace category_theory
open category_theory.limits

universes u v


-- TODO: Move this
section
variables {C : Type u} [ùíû : category.{u v} C]
include ùíû

def coext_equiv {X Y : C}
  (e : Œ† {Z : C}, (Y ‚ü∂ Z) ‚âÉ (X ‚ü∂ Z))
  (n : Œ† {Z Z' : C} (f : Z ‚ü∂ Z') (g : Y ‚ü∂ Z), e.to_fun (g ‚â´ f) = e.to_fun g ‚â´ f) : X ‚âÖ Y :=
{ hom := e.to_fun (ùüô _),
  inv := e.inv_fun (ùüô _),
  hom_inv_id' := begin rw ‚Üên, simpa using e.right_inv _ end,
  inv_hom_id' := begin
    rw ‚Üêe.apply_eq_iff_eq,
    convert ‚Üên _ _,
    convert category.id_comp _ _,
    apply e.right_inv
  end }

lemma coext_equiv_hom_comp {X Y Z : C} {e : Œ† {Z : C}, (Y ‚ü∂ Z) ‚âÉ (X ‚ü∂ Z)} {n} {f : Y ‚ü∂ Z} :
  (coext_equiv @e n).hom ‚â´ f = e.to_fun f :=
by convert (n _ _).symm; simp

lemma coext_equiv_hom {X Y : C} {e : Œ† {Z : C}, (Y ‚ü∂ Z) ‚âÉ (X ‚ü∂ Z)} {n} :
  (coext_equiv @e n).hom = e.to_fun (ùüô _) := rfl

end


-- TODO: How much of this should be generalized to a possibly large category?
variables (C : Type v) [ùíû : small_category.{v} C]
include ùíû

def presheaf := C·µí·µñ ‚•§ Type v

instance presheaf.category : category (presheaf C) := by dunfold presheaf; apply_instance
instance presheaf.has_colimits : has_colimits.{v+1 v} (presheaf C) :=
by dunfold presheaf; apply_instance

variables {C}

section category_of_elements

variables (X : presheaf C)

-- TODO: Implement this as the comma category of `yoneda` over X?
structure category_of_elements :=
(c : C)
(e : yoneda.obj c ‚üπ X)

instance category_of_elements.category : category (category_of_elements X) :=
{ hom := Œª a b, {f : a.c ‚ü∂ b.c // a.e = (yoneda.map f).vcomp b.e },
  id := Œª a, ‚ü®ùüô _, by tidy‚ü©,
  comp := Œª a b c f g,
    ‚ü®f.1 ‚â´ g.1, begin
       cases f with f hf, cases g with g hg,
       dsimp { iota := tt },
       rw [hf, hg],
       tidy
     end‚ü© }

def category_of_elements.forget : category_of_elements X ‚•§ C :=
{ obj := Œª a, a.c, map := Œª a b f, f.1 }

end category_of_elements

section extension
variables {D : Type u} [ùíü : category.{u v} D] (F : C ‚•§ D)
include ùíü

def restricted_yoneda : D ‚•§ C·µí·µñ ‚•§ Type v :=
{ obj := Œª d,
  { obj := Œª c, F.obj c ‚ü∂ d,
    map := Œª c c' f h, F.map f ‚â´ h,
    map_id' := Œª c, by ext h; erw [F.map_id, category.id_comp]; refl,
    map_comp' := Œª c c' c'' f f', by ext h; erw [F.map_comp, category.assoc]; refl },
  map := Œª d d' g, { app := Œª c h, h ‚â´ g } }

variables [has_colimits.{u v} D]

def yoneda_extension_obj : presheaf C ‚Üí D :=
Œª X, colimit ((category_of_elements.forget X).comp F)

def yoneda_extension_e (X Y) :
  (yoneda_extension_obj F X ‚ü∂ Y) ‚âÉ (X ‚ü∂ (restricted_yoneda F).obj Y) :=
calc
  (colimit _ ‚ü∂ Y)
    ‚âÉ ((category_of_elements.forget X).comp F ‚üπ (functor.const _).obj Y)
    : (colimit.universal_property _).equiv
... ‚âÉ { t : Œ† (c : C) (e : yoneda.obj c ‚üπ X), F.obj c ‚ü∂ Y //
        ‚àÄ (c c' : C) (f : c' ‚ü∂ c) (e : yoneda.obj c ‚üπ X),
          t c' ((yoneda.map f).vcomp e) = F.map f ‚â´ t c e }
    : ‚ü®Œª t,
         ‚ü®Œª c e, t.app ‚ü®c, e‚ü©,
          Œª c d f e, begin
            erw @nat_trans.naturality _ _ _ _ _ _ t ‚ü®d, yoneda.map f ‚äü e‚ü© ‚ü®c, e‚ü© ‚ü®f, rfl‚ü©,
            erw category.comp_id
          end‚ü©,
       Œª t,
         { app := Œª a, t.1 a.1 a.2,
           naturality' := Œª a b f, by erw [f.2, ‚Üêt.2 b.1 a.1 f.1 b.2, category.comp_id] },
       Œª t, by cases t; ext1 ce; cases ce; refl,
       Œª t, by cases t; refl‚ü©
... ‚âÉ { t : Œ† (c : C) (e : X.obj c), F.obj c ‚ü∂ Y // _ }
    : equiv.subtype_equiv_of_subtype $ equiv.Pi_congr_right $ Œª c,
        equiv.arrow_congr (yoneda_equiv X) (equiv.refl _)
... ‚âÉ { t : Œ† (c : C) (e : X.obj c), F.obj c ‚ü∂ Y //
        ‚àÄ c c' (f : c ‚ü∂ c'), X.map f ‚â´ t c' = t c ‚â´ ((restricted_yoneda F).obj Y).map f }
    : begin
        apply equiv.subtype_equiv_subtype,
        ext t,
        apply forall_congr, intro c,
        apply forall_congr, intro c',
        apply forall_congr, intro f,
        dsimp [equiv.Pi_congr_right, equiv.arrow_congr, equiv.refl, yoneda_equiv],
        split; intro H,
        { ext e,
          have : e = (yoneda_equiv X).to_fun ((yoneda_equiv X).inv_fun e),
            by rw (yoneda_equiv X).right_inv,
          rw this,
          convert H ((yoneda_equiv X).inv_fun e),
          rw ‚Üêthis,
          simp [yoneda_equiv] },
        { intro e,
          convert congr_fun H ((yoneda_equiv X).to_fun e),
          dsimp [yoneda_equiv],
          convert functor_to_types.naturality _ _ e f (ùüô c) using 2,
          simp }
      end
... ‚âÉ (X ‚ü∂ (restricted_yoneda F).obj Y)
    : ‚ü®Œª t, { app := t.1, naturality' := Œª c c' f, by apply t.2 },
       Œª t, ‚ü®t.app, Œª c c' f, by apply t.naturality‚ü©,
       Œª t, by cases t; refl,
       Œª t, by cases t; refl‚ü©

lemma yoneda_extension_e_natural (X Y Y') (g : Y ‚ü∂ Y') (h) :
  (yoneda_extension_e F X Y').to_fun (h ‚â´ g) =
  (yoneda_extension_e F X Y).to_fun h ‚â´ (restricted_yoneda F).map g :=
by ext c e; symmetry; apply category.assoc

def yoneda_extension : presheaf C ‚•§ D :=
adjunction.left_adjoint_of_equiv (yoneda_extension_e F) (yoneda_extension_e_natural F)

def yoneda_extension_adj : adjunction (yoneda_extension F) (restricted_yoneda F) :=
by apply adjunction.adjunction_of_equiv_left

local attribute [elab_simple] yoneda_extension -- to infer universe parameters
def yoneda_extension_is_extension : yoneda ‚ãô yoneda_extension F ‚âÖ F :=
nat_iso.of_components
  (Œª c, coext_equiv
     (Œª Z, calc
         (F.obj c ‚ü∂ Z)
           ‚âÉ ((restricted_yoneda F).obj Z).obj c           : equiv.refl _
       ... ‚âÉ (yoneda.obj c ‚üπ (restricted_yoneda F).obj Z)  : (yoneda_equiv _).symm
       ... ‚âÉ ((yoneda ‚ãô yoneda_extension F).obj c ‚ü∂ Z)
           : (yoneda_extension_adj F).hom_equiv.symm)
     begin
       intros d d' f g,
       dsimp [equiv.trans, equiv.symm, equiv.refl],
       rw ‚Üêadjunction.hom_equiv_symm_naturality', congr,
       dsimp [yoneda_equiv], ext c', dsimp [restricted_yoneda], simp
     end)
  begin
    intros c c' f,
    dsimp [equiv.trans, equiv.symm, equiv.refl],
    rw [coext_equiv_hom, coext_equiv_hom_comp],
    dsimp, rw ‚Üêadjunction.hom_equiv_symm_naturality, congr,
    convert yoneda_equiv_symm_nat f _,
    dsimp [restricted_yoneda], simp
  end

end extension


section canonical_diagram

variables (X : presheaf C)

def restricted_yoneda_yoneda_iso_id : restricted_yoneda yoneda ‚âÖ functor.id (presheaf C) :=
nat_iso.of_components
  (Œª X, begin
     fapply nat_iso.of_components,
     { exact Œª c, iso_of_equiv (yoneda_equiv X : _ ‚âÉ X.obj c) },
     { intros c c' f, ext t,
       dsimp [iso_of_equiv],
       erw yoneda_equiv_nat, refl }
   end)
  (by intros X Y f; ext c e; refl)

def id_iso_yoneda_extension_yoneda : functor.id (presheaf C) ‚âÖ yoneda_extension yoneda :=
(adjunction.nat_iso_equiv (yoneda_extension_adj _) adjunction.id).inv_fun
  restricted_yoneda_yoneda_iso_id

-- So, we showed that the colimit of the canonical diagram is isomorphic to X, *somehow*!
-- Can we identify the colimit cone as the obvious one?

-- Old stuff below

def canonical_diagram : category_of_elements X ‚•§ presheaf C :=
(category_of_elements.forget X).comp yoneda

def canonical_diagram.to_original :
  canonical_diagram X ‚üπ (functor.const (category_of_elements X)).obj X :=
{ app := Œª a, a.e,
  naturality' := Œª a b f, by rw f.2; refl }

def canonical_diagram.cocone : cocone (canonical_diagram X) :=
{ X := X, Œπ := canonical_diagram.to_original X }

end canonical_diagram

end category_theory
