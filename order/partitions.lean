import data.set.lattice order.order_iso

open function

variable {Œ± : Type*}

namespace set

lemma inter_of_subset {A B : set Œ±} (h : A ‚äÜ B) : A ‚à© B = A :=
by simp [set.ext_iff]; exact Œª a, iff.intro (Œª H, H.1) (Œª H, ‚ü®H, set.mem_of_mem_of_subset H h‚ü©)

theorem disjoint_left {s t : set Œ±} : disjoint s t ‚Üî ‚àÄ {a}, a ‚àà s ‚Üí a ‚àâ t :=
by { simp [disjoint, set.subset_def, set.ext_iff],
change (‚àÄ (x : Œ±), x ‚àà s ‚à© t ‚Üî x ‚àà ‚àÖ) ‚Üî ‚àÄ {a : Œ±}, a ‚àà s ‚Üí a ‚àâ t, simp }

end set

namespace setoid

lemma sub_of_gen_sub (x : Œ± ‚Üí Œ± ‚Üí Prop) (s : setoid Œ±) (H : ‚àÄ a b : Œ±, x a b ‚Üí @setoid.r _ s a b) :
‚àÄ a b : Œ±, (eqv_gen x) a b ‚Üí @setoid.r _ s a b :=
Œª a b H2, eqv_gen.rec_on H2 H
  (@setoid.iseqv Œ± s).1
  (Œª x y _ H3, (@setoid.iseqv Œ± s).2.1 H3)
  (Œª x y z _ _ H4 H5,(@setoid.iseqv Œ± s).2.2 H4 H5)

def top : setoid Œ± :=
{ r := Œª s‚ÇÅ s‚ÇÇ, true,
  iseqv := by { unfold equivalence reflexive symmetric transitive,
    exact ‚ü®by { intro, trivial }, by { intros, trivial }, by { intros, trivial }‚ü© }}

def bot : setoid Œ± :=
{ r := (=),
  iseqv := by { unfold equivalence reflexive symmetric transitive,
    exact ‚ü®by { intro, refl }, by { intros, exact a.symm }, by { intros, exact eq.trans a a_1 }‚ü© }}

theorem eq_iff_r_eq : ‚àÄ {r‚ÇÅ r‚ÇÇ : setoid Œ±}, r‚ÇÅ = r‚ÇÇ ‚Üî r‚ÇÅ.r = r‚ÇÇ.r
| ‚ü®r1, e1‚ü© ‚ü®r2, e2‚ü© :=
iff.intro (Œª h, by injection h) (Œª h, by dsimp at h; subst h)

theorem eq_iff_eqv_class_eq {r‚ÇÅ r‚ÇÇ : setoid Œ±} :
  r‚ÇÅ = r‚ÇÇ ‚Üî (‚àÄ a, let r1 := r‚ÇÅ.r in let r2 := r‚ÇÇ.r in {b | r1 a b} = {b | r2 a b}) :=
by rw eq_iff_r_eq; exact iff.intro (by { intros h a r1 r2, have : r1 = r2 := h, rw this })
  ( Œª h, by apply funext; exact h )

instance : has_subset (setoid Œ±) :=
‚ü®Œª r‚ÇÅ r‚ÇÇ, ‚àÄ (a : Œ±), let r1 := r‚ÇÅ.r in let r2 := r‚ÇÇ.r in {b | r1 a b} ‚äÜ {b | r2 a b}‚ü©

theorem subset_def (r‚ÇÅ r‚ÇÇ : setoid Œ±) : r‚ÇÅ ‚äÜ r‚ÇÇ ‚Üî ‚àÄ (a : Œ±), let r1 := r‚ÇÅ.r in
  let r2 := r‚ÇÇ.r in {b | r1 a b} ‚äÜ {b | r2 a b} :=
iff.rfl

@[simp] theorem subset.refl (r : setoid Œ±) : r ‚äÜ r :=
by rw [subset_def]; exact assume _, set.subset.refl _

theorem subset.trans {r‚ÇÅ r‚ÇÇ r‚ÇÉ : setoid Œ±} : r‚ÇÅ ‚äÜ r‚ÇÇ ‚Üí r‚ÇÇ ‚äÜ r‚ÇÉ ‚Üí r‚ÇÅ ‚äÜ r‚ÇÉ :=
by iterate { rw [subset_def] }; exact assume h‚ÇÅ h‚ÇÇ a, set.subset.trans (h‚ÇÅ a) (h‚ÇÇ a)

theorem subset.antisymm {r‚ÇÅ r‚ÇÇ : setoid Œ±} (H‚ÇÅ : r‚ÇÅ ‚äÜ r‚ÇÇ) (H‚ÇÇ : r‚ÇÇ ‚äÜ r‚ÇÅ) :
r‚ÇÅ = r‚ÇÇ :=
begin
  rw subset_def at H‚ÇÅ H‚ÇÇ,
  rw eq_iff_eqv_class_eq,
  intro a,
  exact set.subset.antisymm (H‚ÇÅ a) (H‚ÇÇ a)
end

instance : has_ssubset (setoid Œ±) := ‚ü®Œªa b, a ‚äÜ b ‚àß ¬¨ b ‚äÜ a‚ü©

def rel_union (r‚ÇÅ r‚ÇÇ : setoid Œ±) : Œ± ‚Üí Œ± ‚Üí Prop :=
Œª s‚ÇÅ s‚ÇÇ, let r1 := r‚ÇÅ.r in let r2 := r‚ÇÇ.r in r1 s‚ÇÅ s‚ÇÇ ‚à® r2 s‚ÇÅ s‚ÇÇ

protected def union (r‚ÇÅ r‚ÇÇ : setoid Œ±) : setoid Œ± :=
eqv_gen.setoid $ rel_union r‚ÇÅ r‚ÇÇ

instance : has_union (setoid Œ±) :=
‚ü®setoid.union‚ü©

theorem union_def {r‚ÇÅ r‚ÇÇ : setoid Œ±} : r‚ÇÅ ‚à™ r‚ÇÇ =
eqv_gen.setoid (rel_union r‚ÇÅ r‚ÇÇ) :=
rfl

@[simp] theorem subset_union_left (s t : setoid Œ±) : s ‚äÜ s ‚à™ t :=
by simp only [subset_def, set.subset_def]; exact Œª a x h, eqv_gen.rel a x (or.inl h)

@[simp] theorem subset_union_right (s t : setoid Œ±) : t ‚äÜ s ‚à™ t :=
by simp only [subset_def, set.subset_def]; exact Œª a x h, eqv_gen.rel a x (or.inr h)

theorem union_subset {r‚ÇÅ r‚ÇÇ r‚ÇÉ : setoid Œ±} (h13 : r‚ÇÅ ‚äÜ r‚ÇÉ) (h23 : r‚ÇÇ ‚äÜ r‚ÇÉ) : r‚ÇÅ ‚à™ r‚ÇÇ ‚äÜ r‚ÇÉ :=
by simp only [subset_def, set.subset_def, set.mem_set_of_eq] at h13 h23 ‚ä¢;
exact Œª a x h, sub_of_gen_sub (rel_union r‚ÇÅ r‚ÇÇ) r‚ÇÉ
  (Œª x' y' h', or.elim h' (h13 x' y') (h23 x' y')) a x h

protected def inter (r‚ÇÅ r‚ÇÇ : setoid Œ±) : setoid Œ± :=
{ r := Œª s‚ÇÅ s‚ÇÇ, let r1 := r‚ÇÅ.r in let r2 := r‚ÇÇ.r in r1 s‚ÇÅ s‚ÇÇ ‚àß r2 s‚ÇÅ s‚ÇÇ,
  iseqv := ‚ü®Œª x, ‚ü®r‚ÇÅ.2.1 x, r‚ÇÇ.2.1 x‚ü©, (Œª x y h, ‚ü®r‚ÇÅ.2.2.1 h.1, r‚ÇÇ.2.2.1 h.2‚ü©),
      Œª x y z h‚ÇÅ h‚ÇÇ, ‚ü®r‚ÇÅ.2.2.2 h‚ÇÅ.1 h‚ÇÇ.1, r‚ÇÇ.2.2.2 h‚ÇÅ.2 h‚ÇÇ.2‚ü©‚ü© }

instance : has_inter (setoid Œ±) :=
‚ü®setoid.inter‚ü©

theorem inter_def {r‚ÇÅ r‚ÇÇ : setoid Œ±} : r‚ÇÅ ‚à© r‚ÇÇ =
{ r := Œª s‚ÇÅ s‚ÇÇ, let r1 := r‚ÇÅ.r in let r2 := r‚ÇÇ.r in r1 s‚ÇÅ s‚ÇÇ ‚àß r2 s‚ÇÅ s‚ÇÇ,
  iseqv := ‚ü®Œª x, ‚ü®r‚ÇÅ.2.1 x, r‚ÇÇ.2.1 x‚ü©, (Œª x y h, ‚ü®r‚ÇÅ.2.2.1 h.1, r‚ÇÇ.2.2.1 h.2‚ü©),
      Œª x y z h‚ÇÅ h‚ÇÇ, ‚ü®r‚ÇÅ.2.2.2 h‚ÇÅ.1 h‚ÇÇ.1, r‚ÇÇ.2.2.2 h‚ÇÅ.2 h‚ÇÇ.2‚ü©‚ü© } := rfl

@[simp] theorem inter_subset_left (r‚ÇÅ r‚ÇÇ : setoid Œ±) : r‚ÇÅ ‚à© r‚ÇÇ ‚äÜ r‚ÇÅ :=
by simp only [subset_def, set.subset_def]; exact Œª a x h, and.left h

@[simp] theorem inter_subset_right (r‚ÇÅ r‚ÇÇ : setoid Œ±) : r‚ÇÅ ‚à© r‚ÇÇ ‚äÜ r‚ÇÇ :=
by simp only [subset_def, set.subset_def]; exact Œª a x h, and.right h

theorem subset_inter {s t r : setoid Œ±} (rs : r ‚äÜ s) (rt : r ‚äÜ t) : r ‚äÜ s ‚à© t :=
by rw [subset_def] at rs rt ‚ä¢; exact Œª a, set.subset_inter (rs a) (rt a)

theorem le_top (r : setoid Œ±) : r ‚äÜ top :=
by simp only [subset_def, set.subset_def];
exact Œª a x h, trivial

theorem bot_le (r : setoid Œ±) : bot ‚äÜ r :=
by simp only [subset_def, bot, set.subset_def, set.mem_set_of_eq]; exact Œª a x h, h.symm ‚ñ∏ (r.2.1 x)

def Sup (s : set (setoid Œ±)) : setoid Œ± :=
eqv_gen.setoid $ Œª (x y : Œ±), ‚àÉ r' : setoid Œ±, r' ‚àà s ‚àß @r Œ± r' x y

lemma le_Sup (s : set (setoid Œ±)) : ‚àÄ a ‚àà s, a ‚äÜ Sup s :=
by simp only [subset_def, set.subset_def];
exact Œª a H _ _ h, eqv_gen.rel _ _ (exists.intro a ‚ü®H, h‚ü©)

lemma Sup_le (s : set (setoid Œ±)) (a : setoid Œ±) : (‚àÄ b ‚àà s, b ‚äÜ a) ‚Üí Sup s ‚äÜ a :=
by simp only [subset_def, set.subset_def, set.mem_set_of_eq, Sup];
exact Œª H x y h, let rsup := Œª x y, ‚àÉ r', r' ‚àà s ‚àß @r Œ± r' x y in
  sub_of_gen_sub rsup a (Œª x' y' h', exists.elim h' (Œª b' hb', H b' hb'.1 x' y' hb'.2)) x y h

def Inf (s : set (setoid Œ±)) : setoid Œ± :=
eqv_gen.setoid $ Œª (x y : Œ±), ‚àÄ r' : setoid Œ±, r' ‚àà s ‚Üí @r Œ± r' x y

lemma Inf_le (s : set (setoid Œ±)) : ‚àÄ a ‚àà s, Inf s ‚äÜ a :=
by simp only [subset_def, set.subset_def, set.mem_set_of_eq, Inf];
exact Œª a H x y h, let rinf := Œª x y, ‚àÄ r', r' ‚àà s ‚Üí @r Œ± r' x y in
  sub_of_gen_sub rinf a (Œª x' y' h', h' a H) x y h

lemma le_Inf (s : set (setoid Œ±)) (a : setoid Œ±) : (‚àÄ b ‚àà s, a ‚äÜ b) ‚Üí a ‚äÜ Inf s :=
by simp only [subset_def, set.subset_def, set.mem_set_of_eq, Inf];
exact Œª H x y h, eqv_gen.rel x y (Œª r' hr', H r' hr' x y h)

instance lattice_setoid : lattice.complete_lattice (setoid Œ±) :=
{ lattice.complete_lattice .
  le           := (‚äÜ),
  le_refl      := subset.refl,
  le_trans     := assume a b c, subset.trans,
  le_antisymm  := assume a b, subset.antisymm,

  lt           := (‚äÇ),
  lt_iff_le_not_le := Œª x y, iff.refl _,

  sup          := (‚à™),
  le_sup_left  := subset_union_left,
  le_sup_right := subset_union_right,
  sup_le       := assume a b c, union_subset,

  inf          := (‚à©),
  inf_le_left  := inter_subset_left,
  inf_le_right := inter_subset_right,
  le_inf       := assume a b c, subset_inter,

  top          := top,
  le_top       := le_top,

  bot          := bot,
  bot_le       := bot_le,

  Sup          := Sup,
  le_Sup       := le_Sup,
  Sup_le       := Sup_le,

  Inf          := Inf,
  le_Inf       := le_Inf,
  Inf_le       := Inf_le }

variables (Œ±) (ùîØ : setoid Œ±)

/- We define a partition as a family of nonempty sets such that any element of Œ± is contained in
exactly one set -/

/- Is there a way to set this up so that we talk about the equivalence classes via quot? -/
structure partition :=
(blocks : set (set Œ±))
(empty_not_mem_blocks : ‚àÖ ‚àâ blocks)
(blocks_partition : ‚àÄ a, ‚àÉ b, b ‚àà blocks ‚àß a ‚àà b ‚àß ‚àÄ b' ‚àà blocks, a ‚àà b' ‚Üí b = b')

variable {Œ±}

theorem disjoint_union_of_partition (P : partition Œ±) :
set.sUnion P.1 = @set.univ Œ± ‚àß
‚àÄ (b‚ÇÅ b‚ÇÇ), b‚ÇÅ ‚àà P.1 ‚Üí b‚ÇÇ ‚àà P.1 ‚Üí b‚ÇÅ ‚â† b‚ÇÇ ‚Üí disjoint b‚ÇÅ b‚ÇÇ :=
begin
  simp [set.ext_iff],
  split,
  { intro a,
      have hP := P.blocks_partition a,
      exact exists.elim hP (by { intros b hb,
        exact exists.intro b ‚ü®hb.1, hb.2.1‚ü© }) },
  { intros b‚ÇÅ b‚ÇÇ hb‚ÇÅ hb‚ÇÇ h,
    rw ‚Üêset.ext_iff at h,
    have HP : ‚àÖ ‚àâ P.blocks := P.empty_not_mem_blocks,
    have hP' := P.blocks_partition,
    have Hb‚ÇÅ : b‚ÇÅ ‚â† ‚àÖ := by { intro h', exact (h'.symm ‚ñ∏ HP) hb‚ÇÅ },
    refine set.disjoint_left.mpr _,
    intros a ha,
    replace hP' := hP' a,
    exact exists.elim hP' (by { intros b' hb',
      have Hb' : b' = b‚ÇÅ := by { have := (hb'.2.2 b‚ÇÅ hb‚ÇÅ), exact this ha }, intro h',
      exact h (eq.trans Hb'.symm $ hb'.2.2 b‚ÇÇ hb‚ÇÇ $ Hb'.symm ‚ñ∏ h') }) }
end

def partition_of_disjoint_union {P : set (set Œ±)} (h‚ÇÅ : ‚àÖ ‚àâ P)
(h‚ÇÇ : set.sUnion P = @set.univ Œ±)
(h‚ÇÉ : ‚àÄ (b‚ÇÅ b‚ÇÇ), b‚ÇÅ ‚àà P ‚Üí b‚ÇÇ ‚àà P ‚Üí b‚ÇÅ ‚â† b‚ÇÇ ‚Üí disjoint b‚ÇÅ b‚ÇÇ) : partition Œ± :=
by simp [set.ext_iff] at h‚ÇÇ;
exact { blocks := P,
  empty_not_mem_blocks := h‚ÇÅ,
  blocks_partition := assume (a : Œ±),
    by replace h‚ÇÇ : ‚àÉ b, b ‚àà P ‚àß a ‚àà b := h‚ÇÇ a;
    exact exists.elim h‚ÇÇ (assume (b : set Œ±)
      (hb : b ‚àà P ‚àß a ‚àà b),
      and.elim hb $ assume (hb : b ‚àà P) (hab : a ‚àà b),
        exists.intro b ‚ü®hb,hab,assume (b' : set Œ±) (hb' : b' ‚àà P) (hab' : a ‚àà b'),
          by { have := mt (h‚ÇÉ b b' hb hb'), haveI := classical.prop_decidable,
            simp at this, refine this (mt disjoint_iff.mp _),
            change b ‚à© b' ‚â† ‚àÖ,
            refine @set.ne_empty_of_mem _ (b ‚à© b') a _,
            exact set.mem_inter hab hab' }‚ü©) }

namespace partition
variables {Œ±} (P : partition Œ±)

theorem eq_of_blocks_eq : ‚àÄ {P‚ÇÅ P‚ÇÇ : partition Œ±}, P‚ÇÅ = P‚ÇÇ ‚Üî P‚ÇÅ.blocks = P‚ÇÇ.blocks
| ‚ü®_, _, _‚ü© ‚ü®_, _, _‚ü© :=
by simp

theorem ext {P‚ÇÅ P‚ÇÇ : partition Œ±} : P‚ÇÅ = P‚ÇÇ ‚Üî ‚àÄ b, b ‚àà P‚ÇÅ.1 ‚Üî b ‚àà P‚ÇÇ.1 :=
by simp only [eq_of_blocks_eq, set.ext_iff]

@[extensionality]
theorem ext' {P‚ÇÅ P‚ÇÇ : partition Œ±} : (‚àÄ b, b ‚àà P‚ÇÅ.1 ‚Üî b ‚àà P‚ÇÇ.1) ‚Üí P‚ÇÅ = P‚ÇÇ :=
ext.2

theorem setoid_blocks_partition : ‚àÄ a : Œ±, ‚àÉ b : set Œ±, b ‚àà {t | ‚àÉ a : Œ±, {b | a ‚âà b} = t} ‚àß
  a ‚àà b ‚àß ‚àÄ b' ‚àà {t | ‚àÉ a : Œ±, {b | a ‚âà b} = t}, a ‚àà b' ‚Üí b = b' :=
let r' := ùîØ.r in
  assume a, by { exact exists.intro {b | a ‚âà b}
    (by { split, { exact exists.intro a rfl },
      { split, { simp },
        { simp only [set.ext_iff, set.mem_set_of_eq],
          intros x h‚ÇÅ h‚ÇÇ a',
          exact exists.elim h‚ÇÅ (by { intros y hy,
            have ha : y ‚âà a := (hy a).mpr h‚ÇÇ, have ha' : y ‚âà a' ‚Üî a' ‚àà x := hy a',
            split, { intro H, exact ha'.mp (setoid.trans ha H) },
            { intro H, exact setoid.trans (setoid.symm ha) (ha'.mpr H) } }) }}})}

/- There is a partition associated to an equivalence relation on a set -/
def coe_of_setoid : partition Œ± :=
let r' := ùîØ.r in
{ blocks := {t | ‚àÉ a, {b | a ‚âà b} = t},
  empty_not_mem_blocks := by { rw [set.nmem_set_of_eq], intro h,
    exact exists.elim h (by { intros a ha, simp [set.eq_empty_iff_forall_not_mem] at ha,
      exact ha a (setoid.refl a) }) },
  blocks_partition := setoid_blocks_partition ùîØ }

def setoid_of_partition : setoid Œ± :=
{ r := Œª x y, ‚àÉ b, b ‚àà P.blocks ‚àß x ‚àà b ‚àß y ‚àà b,
  iseqv := ‚ü®Œª x, exists.elim (P.blocks_partition x) (Œª b h, exists.intro b ‚ü®h.1, h.2.1, h.2.1‚ü©),
    Œª x y H, exists.elim H (Œª b hb, exists.intro b ‚ü®hb.1, hb.2.2, hb.2.1‚ü©),
    Œª x y z hxy hyz, exists.elim hxy $ Œª b hb, exists.elim hyz $
      Œª b' hb', exists.elim (P.blocks_partition y) $
        Œª b'' hb'', by { have Hb : b'' = b := hb''.2.2 b hb.1 hb.2.2,
          have Hb' : b'' = b' := hb''.2.2 b' hb'.1 hb'.2.1,
          exact exists.intro b'' ‚ü®hb''.1, Hb.symm ‚ñ∏ hb.2.1, Hb'.symm ‚ñ∏ hb'.2.2‚ü© }‚ü© }

theorem setoid_partition_setoid : setoid_of_partition (coe_of_setoid ùîØ) = ùîØ :=
begin
  unfold setoid_of_partition coe_of_setoid,
  simp [setoid.eq_iff_r_eq],
  ext x y, split,
  { intro H, exact exists.elim H (Œª b hb, exists.elim hb.1
    (by { intros a ha,
    have hax : x ‚âà a := by { have := ha.substr hb.2.1, rw [set.mem_set_of_eq] at this,
      exact setoid.symm this },
    have hay : y ‚âà a := by { have := ha.substr hb.2.2, rw [set.mem_set_of_eq] at this,
      exact setoid.symm this },
    exact setoid.trans hax (setoid.symm hay) })) },
  { intro H, exact exists.elim (setoid_blocks_partition ùîØ x)
    (by { intros b h, exact exists.intro b (‚ü®exists.intro x $ exists.elim h.1 $
      Œª y' hy', by { simp only [set.ext_iff, set.mem_set_of_eq] at hy' ‚ä¢,
        have Hy'x : y' ‚âà x := (hy' x).mpr h.2.1,
        intro a, split, { intro ha, exact (hy' a).mp (setoid.trans Hy'x ha) },
        { intro ha, exact setoid.trans (setoid.symm Hy'x) ((hy' a).mpr ha) } },
      h.2.1, exists.elim h.1 $ Œª y' hy', by simp [set.ext_iff] at hy';
        exact (hy' y).mp (setoid.trans ((hy' x).mpr h.2.1) H : y' ‚âà y)‚ü©) }) }
end

theorem partition_setoid_partition : coe_of_setoid (setoid_of_partition P) = P :=
begin
  unfold setoid_of_partition coe_of_setoid,
  simp [eq_of_blocks_eq],
  ext x, split,
  { intro H, simp only [set.mem_set_of_eq] at H,
    exact exists.elim H (by { intros a ha,
      replace ha : {y : Œ± | ‚àÉ (b : set Œ±), b ‚àà @blocks Œ± P ‚àß a ‚àà b ‚àß y ‚àà b} = x := ha,
      exact exists.elim (P.blocks_partition a)
        (by { intros x' hx',
          have : x = x' := by { rw ‚Üêha,
            ext y, rw [set.mem_set_of_eq], split,
            { intro hy, exact exists.elim hy
              (Œª b' hb', (hx'.2.2 b' hb'.1 hb'.2.1).substr hb'.2.2) },
            { intro hy, exact exists.intro x' ‚ü®hx'.1, hx'.2.1, hy‚ü©} },
        exact this.symm ‚ñ∏ hx'.1 }) }) },
  { intro H, simp only [set.mem_set_of_eq],
    change ‚àÉ a, {y | ‚àÉ b, b ‚àà P.blocks ‚àß a ‚àà b ‚àß y ‚àà b} = x,
    have xne : x ‚â† ‚àÖ := Œª h, (h.symm ‚ñ∏ P.empty_not_mem_blocks) H,
    exact exists.elim (set.exists_mem_of_ne_empty xne) (by {
      intros a ha,
      exact exists.intro a (by { ext y, simp only [set.mem_set_of_eq],
        split,
        { intro hy, exact exists.elim hy
          (by { intros b hb,
            have := P.blocks_partition a,
            exact exists.elim this
              (by { intros b' hb',
              have hb'b : b' = b := hb'.2.2 b hb.1 hb.2.1,
              have hb'x : b' = x := hb'.2.2 x H ha,
              exact (eq.trans hb'b.symm hb'x).subst hb.2.2, }) }) },
        { intro hy, exact exists.intro x ‚ü®H, ha, hy‚ü© } }) }) }
end

instance : has_subset (partition Œ±) :=
‚ü®Œª P‚ÇÅ P‚ÇÇ, ‚àÄ p ‚àà P‚ÇÅ.1, ‚àÉ q, q ‚àà P‚ÇÇ.1 ‚àß p ‚äÜ q‚ü©

theorem subset_def (P‚ÇÅ P‚ÇÇ : partition Œ±) : P‚ÇÅ ‚äÜ P‚ÇÇ ‚Üî ‚àÄ p ‚àà P‚ÇÅ.1,
‚àÉ q, q ‚àà P‚ÇÇ.1 ‚àß p ‚äÜ q :=
iff.rfl

@[simp] theorem subset.refl (P : partition Œ±) : P ‚äÜ P :=
by rw [subset_def]; exact assume p H, exists.intro p ‚ü®H, set.subset.refl p‚ü©

theorem subset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : partition Œ±} : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÇ ‚äÜ s‚ÇÉ ‚Üí s‚ÇÅ ‚äÜ s‚ÇÉ :=
by iterate { rw subset_def };
exact assume (h‚ÇÅ : ‚àÄ p ‚àà s‚ÇÅ.1, ‚àÉ q, q ‚àà s‚ÇÇ.1 ‚àß p ‚äÜ q)
  (h‚ÇÇ : ‚àÄ p ‚àà s‚ÇÇ.1, ‚àÉ q, q ‚àà s‚ÇÉ.1 ‚àß p ‚äÜ q) (p : set Œ±) (hp : p ‚àà s‚ÇÅ.1),
  exists.elim (h‚ÇÅ p hp : ‚àÉ q, q ‚àà s‚ÇÇ.1 ‚àß p ‚äÜ q)
    (assume (p' : set Œ±) (hp' : p' ‚àà s‚ÇÇ.blocks ‚àß p ‚äÜ p'),
    exists.elim (h‚ÇÇ p' hp'.1 : ‚àÉ q, q ‚àà s‚ÇÉ.1 ‚àß p' ‚äÜ q) $
      assume (p'' : set Œ±) (hp'' : p'' ‚àà s‚ÇÉ.blocks ‚àß p' ‚äÜ p''),
      exists.intro p'' ‚ü®hp''.1, set.subset.trans hp'.2 hp''.2‚ü©)

theorem subset.antisymm {s‚ÇÅ s‚ÇÇ : partition Œ±} (H‚ÇÅ : s‚ÇÅ ‚äÜ s‚ÇÇ) (H‚ÇÇ : s‚ÇÇ ‚äÜ s‚ÇÅ) :
s‚ÇÅ = s‚ÇÇ :=
begin
  haveI := classical.prop_decidable,
  rw subset_def at H‚ÇÅ H‚ÇÇ,
  have hs‚ÇÅ := disjoint_union_of_partition s‚ÇÅ, have hs‚ÇÇ := disjoint_union_of_partition s‚ÇÇ,
  ext,
  exact iff.intro (assume (h : b ‚àà s‚ÇÅ.blocks),
    exists.elim (H‚ÇÅ b h) $
      assume (b' : set Œ±) (hb' : b' ‚àà s‚ÇÇ.blocks ‚àß b ‚äÜ b'),
      have ‚àÉ q, q ‚àà s‚ÇÅ.blocks ‚àß b' ‚äÜ q := H‚ÇÇ b' hb'.1,
      exists.elim this $ by { assume (b'' : set Œ±) (hb'' : b'' ‚àà s‚ÇÅ.blocks ‚àß b' ‚äÜ b''),
        replace hs‚ÇÅ := mt (hs‚ÇÅ.2 b b'' h hb''.1), simp at hs‚ÇÅ,
        have : b = b'' := by { refine hs‚ÇÅ _,
          have : b ‚äÜ b'' := set.subset.trans hb'.2 hb''.2,
          have hinter : b ‚à© b'' = b := set.inter_of_subset this,
          have hbne : b ‚â† ‚àÖ := by { by_contra H, simp at H,
            exact s‚ÇÅ.empty_not_mem_blocks (H ‚ñ∏ h) },
          replace hinter := hinter.substr hbne,
          simp [disjoint], exact hinter },
        have b'b : b' = b := set.subset.antisymm (this.symm ‚ñ∏ hb''.2) (hb'.2),
        exact b'b ‚ñ∏ hb'.1 })
    (assume (h : b ‚àà s‚ÇÇ.blocks), exists.elim (H‚ÇÇ b h) $
      assume (b' : set Œ±) (hb' : b' ‚àà s‚ÇÅ.blocks ‚àß b ‚äÜ b'),
      have ‚àÉ q, q ‚àà s‚ÇÇ.blocks ‚àß b' ‚äÜ q := H‚ÇÅ b' hb'.1,
      exists.elim this $ by { assume (b'' : set Œ±) (hb'' : b'' ‚àà s‚ÇÇ.blocks ‚àß b' ‚äÜ b''),
        replace hs‚ÇÇ := mt (hs‚ÇÇ.2 b b'' h hb''.1), simp at hs‚ÇÇ,
        have : b = b'' := by { refine hs‚ÇÇ _,
          have : b ‚äÜ b'' := set.subset.trans hb'.2 hb''.2,
          have hinter : b ‚à© b'' = b := set.inter_of_subset this,
          have hbne : b ‚â† ‚àÖ := by { by_contra H, simp at H,
            exact s‚ÇÇ.empty_not_mem_blocks (H ‚ñ∏ h) },
          replace hinter := hinter.substr hbne,
          simp [disjoint], exact hinter },
        have b'b : b' = b := set.subset.antisymm (this.symm ‚ñ∏ hb''.2) (hb'.2),
        exact b'b ‚ñ∏ hb'.1 })
end

instance : has_ssubset (partition Œ±) := ‚ü®Œªa b, a ‚äÜ b ‚àß ¬¨ b ‚äÜ a‚ü©

/- This instance sets up the poset structure on `partitions Œ±` -/
instance partial_order_of_partitions : partial_order (partition Œ±) :=
{ le := (‚äÜ),
  lt := (‚äÇ),
  le_refl := subset.refl,
  le_trans := @subset.trans _,
  le_antisymm := @subset.antisymm _ }

set_option pp.implicit true

theorem setoid_of_partition_order_preserving (s‚ÇÅ s‚ÇÇ : setoid Œ±) :
  s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üî coe_of_setoid s‚ÇÅ ‚äÜ coe_of_setoid s‚ÇÇ :=
by { simp [coe_of_setoid, subset_def, setoid.subset_def, set.ext_iff, set.subset_def],
    split,
    { intros H p x hx,
      exact exists.intro {x' | @r Œ± s‚ÇÇ x x'}
        ‚ü®exists.intro x (by { intro y, replace hx : ‚àÄ x', @r Œ± s‚ÇÅ x x' ‚Üî x' ‚àà p := hx,
          change @r Œ± s‚ÇÇ x y ‚Üî @r Œ± s‚ÇÇ x y, trivial }),
        by { intros y hy, change @r Œ± s‚ÇÇ x y, exact H x y ((hx y).mpr hy) }‚ü© },
    { intros H x y hxy,
      have := H {x' | @r Œ± s‚ÇÅ x x'} x (by { intro x', trivial }),
      exact exists.elim this (by {
        intros q hq,
        have Hx : x ‚àà q := hq.2 x (s‚ÇÅ.2.1 x),
        have Hy : y ‚àà q := hq.2 y hxy,
        exact exists.elim hq.1 (by { intros a ha,
          have hax : @r Œ± s‚ÇÇ a x := (ha x).mpr Hx,
          have hay : @r Œ± s‚ÇÇ a y := (ha y).mpr Hy,
          exact s‚ÇÇ.2.2.2 (s‚ÇÇ.2.2.1 hax) hay }) }) } }

lemma order_iso_setoid_partition : @order_iso (setoid Œ±) (partition Œ±) (‚äÜ)
  (‚äÜ) :=
{ to_fun := coe_of_setoid,
  inv_fun := setoid_of_partition,
  left_inv := setoid_partition_setoid,
  right_inv := partition_setoid_partition,
  ord := by { intros s‚ÇÅ s‚ÇÇ,
    change s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üî coe_of_setoid s‚ÇÅ ‚äÜ coe_of_setoid s‚ÇÇ,
    exact setoid_of_partition_order_preserving s‚ÇÅ s‚ÇÇ } }

theorem gc : coe_of_setoid ùîØ ‚â§ P ‚Üî ùîØ ‚â§ setoid_of_partition P :=
begin
  change coe_of_setoid ùîØ ‚äÜ P ‚Üî ùîØ ‚äÜ setoid_of_partition P,
  have : coe_of_setoid ùîØ ‚äÜ P ‚Üî coe_of_setoid ùîØ ‚äÜ coe_of_setoid (setoid_of_partition P) :=
    by rw partition_setoid_partition,
  rw [setoid_of_partition_order_preserving],
  rw this
end

protected def galois_insertion : @galois_insertion (setoid Œ±) (partition Œ±) _ _
  (Œª S, coe_of_setoid S) (Œª P, setoid_of_partition P) :=
{ choice := Œª S h, coe_of_setoid S,
  gc := gc,
  le_l_u := Œª P, le_of_eq (partition_setoid_partition P).symm,
  choice_eq := Œª S h, rfl }

instance : lattice.complete_lattice (partition Œ±) :=
partition.galois_insertion.lift_complete_lattice

end partition

end setoid